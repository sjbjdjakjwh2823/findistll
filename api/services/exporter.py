"""
FinDistill Multi-Format Exporter

Exports normalized financial data to:
- JSONL: For LLM fine-tuning
- Markdown: For RAG systems
- Parquet: For analytics (columnar storage)
- HDF5: For large-scale numerical/time-series data
"""

import json
from typing import Dict, Any
from datetime import datetime

class DataExporter:
    """Exports financial data to various formats for AI training."""
    
    def to_jsonl(self, data: Dict[str, Any]) -> str:
        """Convert to JSONL format for LLM fine-tuning."""
        lines = []
        
        # Summary instruction
        lines.append(json.dumps({
            "instruction": "Summarize the key financial findings in this document.",
            "input": data.get("title", "Financial Document"),
            "output": data.get("summary", "No summary available")
        }, ensure_ascii=False))
        
        # Table extraction instructions
        for table in data.get("tables", []):
            table_name = table.get("name", "Table")
            headers = table.get("headers", [])
            rows = table.get("rows", [])
            
            if rows:
                table_text = self._table_to_text(table)
                lines.append(json.dumps({
                    "instruction": f"Analyze the data in the '{table_name}' table.",
                    "input": table_text,
                    "output": f"This table contains {len(headers)} columns and {len(rows)} data rows."
                }, ensure_ascii=False))
                
                # Create Q&A pairs for each row
                for row in rows[:10]:
                    if len(headers) > 0 and len(row) > 0:
                        # Safe zip handling
                        pairs = []
                        for h, v in zip(headers, row):
                            pairs.append(f"{h}: {v}")
                        
                        lines.append(json.dumps({
                            "instruction": f"In '{table_name}', find the data where '{headers[0]}' is '{row[0]}'.",
                            "input": table_text,
                            "output": ", ".join(pairs)
                        }, ensure_ascii=False))
        
        # Key metrics instructions
        for metric, value in data.get("key_metrics", {}).items():
            lines.append(json.dumps({
                "instruction": f"Extract the value for {metric} from the financial statement.",
                "input": data.get("title", "Financial Document"),
                "output": f"{metric}: {value}"
            }, ensure_ascii=False))
        
        return "\n".join(lines)
    
    def to_markdown(self, data: Dict[str, Any]) -> str:
        """Convert to Markdown format for RAG systems."""
        md_lines = []
        
        # Title
        title = data.get("title", "Financial Document")
        md_lines.append(f"# {title}")
        md_lines.append("")
        
        # Metadata
        if "metadata" in data:
            md_lines.append("## Document Information")
            for key, value in data["metadata"].items():
                md_lines.append(f"- **{key}**: {value}")
            md_lines.append("")
        
        # Summary
        if "summary" in data:
            md_lines.append("## Summary")
            md_lines.append(data["summary"])
            md_lines.append("")
        
        # Key Metrics
        if "key_metrics" in data and data["key_metrics"]:
            md_lines.append("## Key Metrics")
            md_lines.append("")
            md_lines.append("| Metric | Value |")
            md_lines.append("|------|-----|")
            for metric, value in data["key_metrics"].items():
                md_lines.append(f"| {metric} | {value} |")
            md_lines.append("")
        
        # Tables
        for i, table in enumerate(data.get("tables", []), 1):
            table_name = table.get("name", f"Table {i}")
            headers = table.get("headers", [])
            rows = table.get("rows", [])
            
            md_lines.append(f"## {table_name}")
            md_lines.append("")
            
            if headers:
                # Sanitized headers
                safe_headers = [str(h).replace("|", "\\|") for h in headers]
                md_lines.append("| " + " | ".join(safe_headers) + " |")
                md_lines.append("|" + "|".join(["---"] * len(headers)) + "|")
                
                for row in rows:
                    padded_row = list(row) + [""] * (len(headers) - len(row))
                    safe_row = [str(v).replace("|", "\\|") for v in padded_row[:len(headers)]]
                    md_lines.append("| " + " | ".join(safe_row) + " |")
            
            md_lines.append("")
        
        # Footer
        md_lines.append("---")
        md_lines.append(f"*Generated by FinDistill at {datetime.now().isoformat()}*")
        
        return "\n".join(md_lines)
    
    def to_parquet(self, data: Dict[str, Any]) -> bytes:
        """
        Convert to Parquet format.
        Warning: This requires pandas/pyarrow which are not installed in serverless mode to save size.
        Will raise an error if called.
        """
        try:
            import pandas as pd
            import pyarrow as pa
            import pyarrow.parquet as pq
            import io
            
            # Implementation if libraries exist
            dfs = []
            for table in data.get("tables", []):
                table_name = table.get("name", "Unknown")
                headers = table.get("headers", [])
                rows = table.get("rows", [])
                
                if headers and rows:
                    df = pd.DataFrame(rows, columns=headers)
                    df["_source_table"] = table_name
                    dfs.append(df)
            
            if not dfs:
                 combined = pd.DataFrame({"info": ["no data"]})
            else:
                 combined = pd.concat(dfs, ignore_index=True)
            
            buffer = io.BytesIO()
            table = pa.Table.from_pandas(combined)
            pq.write_table(table, buffer, compression='snappy')
            return buffer.getvalue()
            
        except ImportError:
            raise RuntimeError("Parquet export not supported in serverless mode (requires pyarrow/pandas)")

    def to_hdf5(self, data: Dict[str, Any]) -> bytes:
        """
        Convert to HDF5 format for large-scale numerical and time-series data.
        Uses float64 precision for financial data accuracy.
        
        Warning: Requires h5py and numpy.
        """
        try:
            import h5py
            import numpy as np
            import io
            
            buffer = io.BytesIO()
            
            with h5py.File(buffer, 'w') as f:
                # Store metadata as attributes
                meta_group = f.create_group("metadata")
                meta_group.attrs["title"] = data.get("title", "Financial Document")
                meta_group.attrs["summary"] = data.get("summary", "")
                meta_group.attrs["created_at"] = datetime.now().isoformat()
                
                # Store key metrics
                if "key_metrics" in data and data["key_metrics"]:
                    metrics_group = f.create_group("key_metrics")
                    for key, value in data["key_metrics"].items():
                        # Try to convert to float64 for precision
                        try:
                            numeric_value = float(str(value).replace(",", "").replace("%", ""))
                            metrics_group.create_dataset(
                                key, 
                                data=np.array([numeric_value], dtype=np.float64)
                            )
                        except (ValueError, TypeError):
                            # Store as string if not numeric
                            metrics_group.attrs[key] = str(value)
                
                # Store tables
                tables_group = f.create_group("tables")
                for i, table in enumerate(data.get("tables", [])):
                    table_name = table.get("name", f"table_{i}")
                    # Clean table name for HDF5 compatibility
                    safe_name = "".join(c if c.isalnum() or c == "_" else "_" for c in table_name)
                    
                    table_group = tables_group.create_group(safe_name)
                    headers = table.get("headers", [])
                    rows = table.get("rows", [])
                    
                    # Store headers
                    if headers:
                        table_group.attrs["headers"] = json.dumps(headers, ensure_ascii=False)
                    
                    # Try to store as numeric array with float64 precision
                    if rows:
                        try:
                            # Attempt to convert to numeric (for financial data)
                            numeric_rows = []
                            for row in rows:
                                numeric_row = []
                                for val in row:
                                    try:
                                        # Clean and convert to float64
                                        clean_val = str(val).replace(",", "").replace("%", "").replace("$", "").replace("â‚©", "")
                                        numeric_row.append(float(clean_val))
                                    except (ValueError, TypeError):
                                        numeric_row.append(float('nan'))
                                numeric_rows.append(numeric_row)
                            
                            # Store as float64 array for precision
                            table_group.create_dataset(
                                "data",
                                data=np.array(numeric_rows, dtype=np.float64),
                                compression="gzip"
                            )
                        except Exception:
                            # Fallback: store as JSON string
                            table_group.attrs["data_json"] = json.dumps(rows, ensure_ascii=False)
            
            return buffer.getvalue()
            
        except ImportError:
            raise RuntimeError("HDF5 export not supported (requires h5py/numpy). Install with: pip install h5py numpy")

    def _table_to_text(self, table: Dict[str, Any]) -> str:
        """Convert a table to readable text format."""
        lines = []
        headers = table.get("headers", [])
        rows = table.get("rows", [])
        
        if headers:
            lines.append("Columns: " + ", ".join(str(h) for h in headers))
        
        for i, row in enumerate(rows[:5], 1):
            val_strs = [str(v) for v in row]
            lines.append(f"Row {i}: " + ", ".join(val_strs))
        
        if len(rows) > 5:
            lines.append(f"... and {len(rows) - 5} other rows")
        
        return "\n".join(lines)


# Singleton instance
exporter = DataExporter()

